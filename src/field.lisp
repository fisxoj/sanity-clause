(defpackage sanity-clause.field
  (:use #:cl
	#:alexandria
	#:cl-arrows)
  (:export #:field
           #:validation-error

	   #:load-field-p
	   #:dump-field-p

	   ;; Fields
	   #:email-field
	   #:member-field
	   #:integer-field
	   #:constant-field

	   ;; Readers
	   #:attribute

	   ;; Methods
	   #:validate
	   #:get-value

	   ;; Errors
	   #:validation-error
	   #:required-value-error
	   )
  (:documentation "Some documentation."))

(in-package :sanity-clause.field)


(deftype missing ()
  :missing)


(defclass field ()
  ((attribute :type (or null symbol)
	      :initarg :attribute
	      :initform nil
	      :reader attribute-of
	      :documentation "Name of the attribute to write the field's value to when serializing, if null, inferred from the name of the field.")
   (data-key :type (or null string)
	     :initarg :data-key
	     :reader data-key-of
	     :documentation "Name of the attribute to read the field's value from when deserializing, if null, inferred form the name of the field.")
   (default :type t
	    :initarg :default
	    :reader default-of
	    :initform :missing
	    :documentation "Value to use during serialization when no value is set.")
   (validator :type (or null function list)
	      :initarg :validator
	      :initform (constantly t)
	      :reader validator-of)
   (data-flow :type (member :both :load :dump)
	      :initarg :flow
	      :initform :both
	      :reader data-flow-of
	      :documentation "If data should only ever be loaded into this field, this is :both (the default).  If data should only be deserialized from the field and ignored when serializing, :load.  If data should only be serialized from the field but ignored during loading, :dump.")
   (required :type boolean
	     :initarg :required
	     :initform nil
	     :reader required-p
	     :documentation "Is this field required?  Casuse the field to fail validation if it's not filled."))
  (:documentation "A base class for all fields that controls how they are (de?)serialized."))


(defun load-field-p (field)
  "Is this field required for deserialization (fields that have flow of :load or :both)?"

  (-> field
      data-flow-of
      (member '(:both :load))))


(defun dump-field-p (field)
  "Is this field required for serialization (fields that have flow of :dump or :both)?"

  (-> field
      data-flow-of
      (member '(:both :dump))))


(defclass string-field (field)
  ()
  (:documentation "A field that contains a string."))

(defclass list-field (field)
  ((element-field :type field
                  :initarg :element-field
                  :reader element-field-of
                  :documentation "The field that respresents the elements of the list."))
  (:documentation "A field that contains a list of values satsified by another field."))

(defclass nested-field (field)
  ((nested-field :type field
                 :initarg :schema
		 :reader schema-of
		 :documentation "A field that represents a complex object located at this field.  The sub-object will be ")))

(defclass boolean-field (field)
  ()
  (:documentation "A field type for bolean values."))


;; (defclass property-list-field (field)
;;   ()
;;   (:documentation "A field for representing associative data as a plist."))

;; (defclass association-list-field (field)
;;   ()
;;   (:documentation "A field for representing associative data as an alist."))

(defclass url-field (string-field)
  ()
  (:documentation "A field for values that should be URLs."))

(defclass email-field (string-field)
  ()
  (:documentation "A field for values that should be emails."))

(defclass member-field (field)
  ()
  (:documentation "A field for values that should be members of a set of symbols."))

(defclass constant-field (field)
  ((constant :initarg :constant
             :reader constant-value-of
             :documentation "The constant value to be serialized or deserialized.")
   (test :initarg :test
	 :initform 'equal
	 :reader constant-test-of
	 :documentation "Function to use to compare the constant value to other values.")))

(defclass integer-field (field)
  ()
  (:documentation "A field that holds an integer value."))

(define-condition field-error (error)
  ()
  (:documentation "Base class for all errors thrown by :package:`sanity-clause.field`."))


(define-condition validation-error (field-error)
  ((error-messages :type list
		   :initarg :error-messages
		   :reader error-messages-of
		   :documentation "A list of any error messages generated by the a field."))
  (:documentation "Error that indicates a field is invalid."))


(define-condition required-value-error (field-error)
  ((missing-field-name :type string
		       :initarg :field-name
		       :reader missing-field-name-of
		       :documentation "The name of the field that is missinga required value."))
  (:documentation "An error that signals a required value is missing."))


(defun all-validators (field)
  "Returns a generator function that yields a validator function each call."

  (declare (type field field))
  (let ((validators (etypecase (validator-of field)
		      (null (list (constantly t)))
		      (function (list (validator-of field)))
		      (list (validator-of field)))))
    (lambda ()
      (pop validators))))


(defun call-validate-validator (validator value)
  "Validator functions from the validate library raise errors rather than returning strings, so handle the error and collect the string."

  ;; Collect nils for non-errors, strings for errors.
  (handler-case (prog1 nil
		  (funcall validator value))
    (v:<validation-error> (e)
      (princ-to-string e))))


(defgeneric validate (field value)
  (:documentation "Run the validation checks for a given field and raise a :class:`sanity-clause.field:validation-error` if it is invalid.")

  (:method ((field field) value)
    (when-let ((errors (->> (loop
			      with validators = (all-validators field)
			      for validator = (funcall validators)
			      while validator

			      collecting (call-validate-validator validator value))
			    (remove-if #'null))))
      (error 'validation-error :error-messages errors))
    (values))

  (:method ((field constant-field) value)
    (unless (funcall (constant-test-of field) (constant-value-of field) value)
      (error 'validation-error :error-messages (list (format nil "Value ~a is not the constant value ~a" value (constant-value-of field)))))))


(defgeneric get-value (field object &optional field-name)
  (:documentation "Tries to fetch the value corresponding to the field from some datastructure.  :param:`field-name` is used if no attribute is explicitly set on the field.")

  (:method ((field field) (object standard-object) &optional field-name)
    (let ((slot-name (or (attribute-of field) field-name)))
      (if (slot-boundp object slot-name)
	  (slot-value object slot-name)
	  (default-of field))))

  (:method ((field field) (object list) &optional field-name)
    (let ((field-marker (or (attribute-of field) field-name)))
      (multiple-value-bind (value found-p)
	  (sanity-clause.util:get-value object field-marker (default-of field))
	(when (and (required-p field) (not found-p))
	  (error 'required-value-error :field-name field-marker))
	value)))

  (:method ((field constant-field) object &optional field-name)
    (constant-value-of field)))
